name: ğŸš€ æ—¥æ¬¡è‡ªå‹•ãƒ–ãƒ­ã‚°ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 

on:
  schedule:
    # æ¯æ—¥åˆå‰9æ™‚ï¼ˆUTC: 00:00 = JST: 09:00ï¼‰ã«å®Ÿè¡Œ
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      keyword:
        description: 'æ‰‹å‹•å®Ÿè¡Œæ™‚ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰'
        required: false
        type: string
      force_generate:
        description: 'å¼·åˆ¶ç”Ÿæˆï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰å¾…ã¡ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰'
        required: false
        type: boolean
        default: false

env:
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  LINE_NOTIFY_TOKEN: ${{ secrets.LINE_NOTIFY_TOKEN }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  check-keyword-status:
    runs-on: ubuntu-latest
    outputs:
      keyword: ${{ steps.keyword-check.outputs.keyword }}
      should_generate: ${{ steps.keyword-check.outputs.should_generate }}
      notification_sent: ${{ steps.keyword-check.outputs.notification_sent }}
    
    steps:
    - name: ğŸ“¥ ãƒªãƒã‚¸ãƒˆãƒªãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
      uses: actions/checkout@v4
      
    - name: ğŸ“‹ Node.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: ğŸ“¦ ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
      run: |
        npm ci
        npm install dotenv axios @actions/core @actions/github
    
    - name: ğŸ” ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰çŠ¶æ³ç¢ºèª
      id: keyword-check
      run: |
        node -e "
        const fs = require('fs');
        const axios = require('axios');
        
        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª
        const requestFile = '.github/keyword-request.json';
        const responseFile = '.github/keyword-response.json';
        
        let shouldGenerate = false;
        let keyword = '';
        let notificationSent = false;
        
        // æ‰‹å‹•å®Ÿè¡Œæ™‚ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ç¢ºèª
        if (process.env.GITHUB_EVENT_NAME === 'workflow_dispatch' && '${{ inputs.keyword }}') {
          keyword = '${{ inputs.keyword }}';
          shouldGenerate = true;
          console.log('Manual keyword provided:', keyword);
        }
        // å¼·åˆ¶ç”Ÿæˆãƒ•ãƒ©ã‚°ç¢ºèª
        else if ('${{ inputs.force_generate }}' === 'true') {
          const fallbackKeywords = [
            'AI ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚° æœ€æ–°å‹•å‘',
            'å¿ƒç†å­¦ ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚° å®Ÿè·µ',
            'CVR æ”¹å–„ å…·ä½“ä¾‹',
            'é¡§å®¢åˆ†æ AI æ´»ç”¨',
            'ãƒ‡ã‚¸ã‚¿ãƒ«å¤‰é© ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°'
          ];
          keyword = fallbackKeywords[Math.floor(Math.random() * fallbackKeywords.length)];
          shouldGenerate = true;
          console.log('Force generate with fallback keyword:', keyword);
        }
        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèª
        else if (fs.existsSync(responseFile)) {
          const response = JSON.parse(fs.readFileSync(responseFile, 'utf8'));
          const now = new Date();
          const responseTime = new Date(response.timestamp);
          const hoursDiff = (now - responseTime) / (1000 * 60 * 60);
          
          // 24æ™‚é–“ä»¥å†…ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹
          if (hoursDiff <= 24 && response.keyword && response.approved) {
            keyword = response.keyword;
            shouldGenerate = true;
            console.log('Using approved keyword:', keyword);
            
            // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤ï¼ˆä½¿ç”¨æ¸ˆã¿ï¼‰
            fs.unlinkSync(responseFile);
          }
        }
        
        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆå¿…è¦æ€§ãƒã‚§ãƒƒã‚¯
        if (!shouldGenerate) {
          let needsRequest = true;
          
          if (fs.existsSync(requestFile)) {
            const request = JSON.parse(fs.readFileSync(requestFile, 'utf8'));
            const requestTime = new Date(request.timestamp);
            const hoursDiff = (now - requestTime) / (1000 * 60 * 60);
            
            // 6æ™‚é–“ä»¥å†…ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ¸ˆã¿ãªã‚‰é€ä¿¡ã—ãªã„
            if (hoursDiff <= 6) {
              needsRequest = false;
              notificationSent = true;
              console.log('Recent request exists, skipping notification');
            }
          }
          
          if (needsRequest) {
            console.log('Need to request keyword from user');
          }
        }
        
        // GitHub Actions outputsè¨­å®š
        console.log('::set-output name=keyword::' + keyword);
        console.log('::set-output name=should_generate::' + shouldGenerate);
        console.log('::set-output name=notification_sent::' + notificationSent);
        "
  
  request-keyword:
    needs: check-keyword-status
    runs-on: ubuntu-latest
    if: needs.check-keyword-status.outputs.should_generate == 'false' && needs.check-keyword-status.outputs.notification_sent == 'false'
    
    steps:
    - name: ğŸ“¥ ãƒªãƒã‚¸ãƒˆãƒªãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
      uses: actions/checkout@v4
      
    - name: ğŸ“‹ Node.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: ğŸ“± ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡
      run: |
        node -e "
        const fs = require('fs');
        const https = require('https');
        const crypto = require('crypto');
        
        // ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDç”Ÿæˆ
        const requestId = crypto.randomUUID();
        const timestamp = new Date().toISOString();
        
        // ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        const requestData = {
          id: requestId,
          timestamp: timestamp,
          status: 'pending',
          message: 'ä»Šæ—¥ã®ãƒ–ãƒ­ã‚°è¨˜äº‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ•™ãˆã¦ãã ã•ã„'
        };
        
        fs.writeFileSync('.github/keyword-request.json', JSON.stringify(requestData, null, 2));
        
        // LINEé€šçŸ¥
        if (process.env.LINE_NOTIFY_TOKEN) {
          const lineData = \`message=ğŸš€ LeadFive ãƒ–ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 
        
ğŸ“ ä»Šæ—¥ã®ãƒ–ãƒ­ã‚°è¨˜äº‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠèã‹ã›ãã ã•ã„
        
â° ç”Ÿæˆäºˆå®šæ™‚åˆ»: \${new Date(Date.now() + 9*60*60*1000).toLocaleString('ja-JP')} (JST)
        
ğŸ’¡ æ¨å¥¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ä¾‹:
â€¢ AI ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚° æœ€æ–°æ‰‹æ³•
â€¢ å¿ƒç†å­¦ å£²ä¸Šå‘ä¸Š å®Ÿä¾‹
â€¢ CVRæ”¹å–„ æˆåŠŸäº‹ä¾‹
â€¢ é¡§å®¢åˆ†æ AIæ´»ç”¨æ³•
        
ğŸ”— å›ç­”æ–¹æ³•: GitHub Issues ã§ '#keyword: ã‚ãªãŸã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰' ã¨æŠ•ç¨¿
        
ãƒªã‚¯ã‚¨ã‚¹ãƒˆID: \${requestId}\`;
        
          const lineOptions = {
            hostname: 'notify-api.line.me',
            port: 443,
            path: '/api/notify',
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Authorization': 'Bearer ' + process.env.LINE_NOTIFY_TOKEN
            }
          };
        
          const lineReq = https.request(lineOptions, (res) => {
            console.log('LINE notification sent, status:', res.statusCode);
          });
        
          lineReq.on('error', (e) => {
            console.error('LINE notification error:', e);
          });
        
          lineReq.write(lineData);
          lineReq.end();
        }
        
        // Slacké€šçŸ¥
        if (process.env.SLACK_WEBHOOK_URL) {
          const slackData = JSON.stringify({
            text: 'ğŸš€ LeadFive ãƒ–ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ  - ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆ',
            blocks: [
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: '*ğŸ“ ä»Šæ—¥ã®ãƒ–ãƒ­ã‚°è¨˜äº‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ãŠèã‹ã›ãã ã•ã„*'
                }
              },
              {
                type: 'section',
                fields: [
                  {
                    type: 'mrkdwn',
                    text: '*â° ç”Ÿæˆäºˆå®šæ™‚åˆ»*\\n' + new Date(Date.now() + 9*60*60*1000).toLocaleString('ja-JP') + ' (JST)'
                  },
                  {
                    type: 'mrkdwn',
                    text: '*ğŸ†” ãƒªã‚¯ã‚¨ã‚¹ãƒˆID*\\n' + requestId
                  }
                ]
              },
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: '*ğŸ’¡ æ¨å¥¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ä¾‹:*\\nâ€¢ AI ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚° æœ€æ–°æ‰‹æ³•\\nâ€¢ å¿ƒç†å­¦ å£²ä¸Šå‘ä¸Š å®Ÿä¾‹\\nâ€¢ CVRæ”¹å–„ æˆåŠŸäº‹ä¾‹\\nâ€¢ é¡§å®¢åˆ†æ AIæ´»ç”¨æ³•'
                }
              },
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: '*ğŸ”— å›ç­”æ–¹æ³•:* GitHub Issues ã§ \`#keyword: ã‚ãªãŸã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰\` ã¨æŠ•ç¨¿ã—ã¦ãã ã•ã„'
                }
              }
            ]
          });
          
          const slackOptions = {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          };
          
          const url = new URL(process.env.SLACK_WEBHOOK_URL);
          const slackReq = https.request({
            hostname: url.hostname,
            port: url.port || 443,
            path: url.pathname,
            ...slackOptions
          }, (res) => {
            console.log('Slack notification sent, status:', res.statusCode);
          });
          
          slackReq.on('error', (e) => {
            console.error('Slack notification error:', e);
          });
          
          slackReq.write(slackData);
          slackReq.end();
        }
        
        console.log('Keyword request sent with ID:', requestId);
        "
    
    - name: ğŸ“¤ ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒŸãƒƒãƒˆ
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .github/keyword-request.json
        git commit -m "ğŸ¤– ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡: $(date '+%Y-%m-%d %H:%M:%S')"
        git push

  generate-blog:
    needs: check-keyword-status
    runs-on: ubuntu-latest
    if: needs.check-keyword-status.outputs.should_generate == 'true'
    
    steps:
    - name: ğŸ“¥ ãƒªãƒã‚¸ãƒˆãƒªãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: ğŸ“‹ Node.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: ğŸ”§ Ruby ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— (Jekyllç”¨)
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.1'
        bundler-cache: true
    
    - name: ğŸ“¦ ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
      run: |
        npm ci
        bundle install
    
    - name: ğŸš€ ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ãƒ–ãƒ­ã‚°ç”Ÿæˆ
      run: |
        cd scripts
        echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" > .env
        echo "GOOGLE_SERP_API_KEY=${{ secrets.GOOGLE_SERP_API_KEY }}" >> .env
        
        KEYWORD="${{ needs.check-keyword-status.outputs.keyword }}"
        echo "Generating blog for keyword: $KEYWORD"
        
        node professional-blog-creator.js "$KEYWORD" || {
          echo "Professional generator failed, trying premium engine..."
          node premium-blog-engine.js "$KEYWORD" || {
            echo "Premium engine failed, using fallback..."
            node auto-blog-scheduler.js --test
          }
        }
    
    - name: ğŸ”¨ Jekyll ãƒ“ãƒ«ãƒ‰
      run: |
        bundle exec jekyll build
    
    - name: âœ… ç”Ÿæˆç¢ºèª
      id: check-generation
      run: |
        # ä»Šæ—¥ç”Ÿæˆã•ã‚ŒãŸè¨˜äº‹ã‚’ç¢ºèª
        TODAY=$(date '+%Y-%m-%d')
        NEW_POST=$(find _posts -name "${TODAY}-*.md" | head -1)
        
        if [ -n "$NEW_POST" ]; then
          echo "Generated post: $NEW_POST"
          POST_TITLE=$(grep '^title:' "$NEW_POST" | sed 's/title: *"*\([^"]*\)"*/\1/')
          echo "Post title: $POST_TITLE"
          echo "::set-output name=success::true"
          echo "::set-output name=filename::$(basename $NEW_POST)"
          echo "::set-output name=title::$POST_TITLE"
        else
          echo "No post generated today"
          echo "::set-output name=success::false"
        fi
    
    - name: ğŸ“¤ å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
      if: steps.check-generation.outputs.success == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "LeadFive Blog Bot"
        
        # ç”Ÿæˆã•ã‚ŒãŸè¨˜äº‹ã¨ãƒ“ãƒ«ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒŸãƒƒãƒˆ
        git add _posts/
        git add _site/
        git add logs/
        
        COMMIT_MSG="ğŸ¤– è‡ªå‹•ãƒ–ãƒ­ã‚°æŠ•ç¨¿: ${{ steps.check-generation.outputs.title }}"
        git commit -m "$COMMIT_MSG" || echo "No changes to commit"
        git push
    
    - name: ğŸ“± æˆåŠŸé€šçŸ¥é€ä¿¡
      if: steps.check-generation.outputs.success == 'true'
      run: |
        node -e "
        const https = require('https');
        const filename = '${{ steps.check-generation.outputs.filename }}';
        const title = '${{ steps.check-generation.outputs.title }}';
        const keyword = '${{ needs.check-keyword-status.outputs.keyword }}';
        const timestamp = new Date().toLocaleString('ja-JP');
        const repoUrl = 'https://github.com/${{ github.repository }}';
        const siteUrl = 'https://${{ github.repository_owner }}.github.io/leadfive/';
        
        // LINEæˆåŠŸé€šçŸ¥
        if (process.env.LINE_NOTIFY_TOKEN) {
          const lineData = \`message=âœ… ãƒ–ãƒ­ã‚°è¨˜äº‹ç”Ÿæˆå®Œäº†ï¼
        
ğŸ“ ã‚¿ã‚¤ãƒˆãƒ«: \${title}
ğŸ¯ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: \${keyword}
ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: \${filename}
â° ç”Ÿæˆæ™‚åˆ»: \${timestamp}
        
ğŸŒ ã‚µã‚¤ãƒˆ: \${siteUrl}
ğŸ“ GitHub: \${repoUrl}
        
ğŸ‰ è¨˜äº‹ã¯æ•°åˆ†å¾Œã«ã‚µã‚¤ãƒˆã«åæ˜ ã•ã‚Œã¾ã™ï¼\`;
        
          const lineOptions = {
            hostname: 'notify-api.line.me',
            port: 443,
            path: '/api/notify',
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
              'Authorization': 'Bearer ' + process.env.LINE_NOTIFY_TOKEN
            }
          };
        
          const lineReq = https.request(lineOptions, (res) => {
            console.log('LINE success notification sent');
          });
        
          lineReq.write(lineData);
          lineReq.end();
        }
        
        // SlackæˆåŠŸé€šçŸ¥
        if (process.env.SLACK_WEBHOOK_URL) {
          const slackData = JSON.stringify({
            text: 'âœ… ãƒ–ãƒ­ã‚°è¨˜äº‹ç”Ÿæˆå®Œäº†ï¼',
            blocks: [
              {
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: '*âœ… ãƒ–ãƒ­ã‚°è¨˜äº‹ç”Ÿæˆå®Œäº†ï¼*'
                }
              },
              {
                type: 'section',
                fields: [
                  {
                    type: 'mrkdwn',
                    text: '*ğŸ“ ã‚¿ã‚¤ãƒˆãƒ«*\\n' + title
                  },
                  {
                    type: 'mrkdwn',
                    text: '*ğŸ¯ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰*\\n' + keyword
                  },
                  {
                    type: 'mrkdwn',
                    text: '*ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«*\\n' + filename
                  },
                  {
                    type: 'mrkdwn',
                    text: '*â° ç”Ÿæˆæ™‚åˆ»*\\n' + timestamp
                  }
                ]
              },
              {
                type: 'actions',
                elements: [
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'ğŸŒ ã‚µã‚¤ãƒˆã‚’è¦‹ã‚‹'
                    },
                    url: siteUrl
                  },
                  {
                    type: 'button',
                    text: {
                      type: 'plain_text',
                      text: 'ğŸ“ GitHub'
                    },
                    url: repoUrl
                  }
                ]
              }
            ]
          });
          
          const url = new URL(process.env.SLACK_WEBHOOK_URL);
          const slackReq = https.request({
            hostname: url.hostname,
            port: 443,
            path: url.pathname,
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            }
          }, (res) => {
            console.log('Slack success notification sent');
          });
          
          slackReq.write(slackData);
          slackReq.end();
        }
        "

    - name: ğŸ“Š ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°
      if: steps.check-generation.outputs.success == 'true'
      run: |
        # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”¨çµ±è¨ˆæ›´æ–°
        node -e "
        const fs = require('fs');
        const statsFile = 'logs/auto-blog-stats.json';
        
        let stats = { total: 0, thisMonth: 0, lastGeneration: null, keywords: [] };
        if (fs.existsSync(statsFile)) {
          stats = JSON.parse(fs.readFileSync(statsFile, 'utf8'));
        }
        
        const now = new Date();
        const thisMonth = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0');
        
        stats.total++;
        stats.thisMonth = stats.keywords.filter(k => k.date.startsWith(thisMonth)).length + 1;
        stats.lastGeneration = now.toISOString();
        stats.keywords.push({
          keyword: '${{ needs.check-keyword-status.outputs.keyword }}',
          title: '${{ steps.check-generation.outputs.title }}',
          filename: '${{ steps.check-generation.outputs.filename }}',
          date: now.toISOString().split('T')[0],
          success: true
        });
        
        // æœ€æ–°100ä»¶ã®ã¿ä¿æŒ
        if (stats.keywords.length > 100) {
          stats.keywords = stats.keywords.slice(-100);
        }
        
        fs.mkdirSync('logs', { recursive: true });
        fs.writeFileSync(statsFile, JSON.stringify(stats, null, 2));
        console.log('Stats updated:', stats.total, 'total articles');
        "
      
    - name: ğŸš¨ ã‚¨ãƒ©ãƒ¼é€šçŸ¥
      if: steps.check-generation.outputs.success == 'false'
      run: |
        echo "Blog generation failed, sending error notification..."
        # ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã®å®Ÿè£…ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        if [ -n "${{ env.LINE_NOTIFY_TOKEN }}" ]; then
          curl -X POST https://notify-api.line.me/api/notify \
            -H "Authorization: Bearer ${{ env.LINE_NOTIFY_TOKEN }}" \
            -d "message=âŒ ãƒ–ãƒ­ã‚°ç”Ÿæˆã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ - GitHub Actions ã‚’ã”ç¢ºèªãã ã•ã„"
        fi